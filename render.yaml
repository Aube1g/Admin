services:
  - type: worker # Используем 'worker', так как бот должен работать постоянно
    name: aube1g-telegram-bot
    env: python
    plan: free
    buildCommand: "pip install -r requirements.txt"
    startCommand: "python Aube1g.py" # Запускаем наш основной файл
    envVars:
      - key: BOT_TOKEN
        sync: false # Устанавливается вручную в панели Render
      - key: PYTHON_VERSION
        value: 3.10.6```

*   Сохраните и выйдите.

---

### **Шаг 3: Полностью новый код для `Aube1g.py`**

Это самый важный шаг. Мы полностью заменяем ваш старый код на новый, который включает в себя:
*   **Исправленный код бота** для актуальной версии библиотеки.
*   **Встроенный веб-сервер** на Flask.
*   **Новый HTML-шаблон** с дизайном в стиле "Мини-Сырок", адаптированный под админ-панель.

**Полностью замените содержимое файла `Aube1g.py` на этот код:**

```python
# Файл: Aube1g.py
# Версия: Интегрированный бот + веб-панель для Render

import logging
import sqlite3
import re
import os
import secrets
import string
from datetime import datetime, timedelta
from threading import Thread

# --- Веб-сервер (Flask) ---
from flask import Flask, jsonify, Response
import requests
from waitress import serve

# --- Бот (Telegram) ---
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters

# ========== ГЛОБАЛЬНЫЕ НАСТРОЙКИ ==========
# Токен будет браться из переменной окружения на Render
BOT_TOKEN = os.environ.get("BOT_TOKEN", "8236417916:AAH7RKGsM-c5xHMtWiXlAmWnQPz44CqRChw") # Резервный токен для локального теста
ADMIN_USERNAME = "Aubeig"
ADMIN_ID = 7467472235
# URL веб-панели будет определен автоматически при запуске на Render
WEB_APP_URL = "" 

# Настройка логирования
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# ========== HTML ШАБЛОН ДЛЯ ВЕБ-ПАНЕЛИ (СТИЛЬ "МИНИ-СЫРОК") ==========
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Панель Администратора</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', 'SF Pro Display', sans-serif; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background: linear-gradient(135deg, #0c0e1a 0%, #1a1b2e 50%, #0d1117 100%); color: #e1e1e1; min-height: 100vh; }
        .container { width: 100%; max-width: 1200px; margin: 20px auto; background: rgba(18, 20, 33, 0.95); border-radius: 20px; box-shadow: 0 10px 35px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.07); backdrop-filter: blur(10px); overflow: hidden; }
        .header { background: linear-gradient(90deg, rgba(40, 48, 72, 0.8) 0%, rgba(26, 32, 44, 0.8) 100%); padding: 20px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.07); }
        .header h1 { font-size: 28px; font-weight: 700; background: linear-gradient(90deg, #6c8dfa 0%, #8a6dfa 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .main-content { display: flex; }
        .sidebar { width: 260px; background: rgba(23, 25, 43, 0.8); border-right: 1px solid rgba(255,255,255,0.07); padding: 20px; }
        .info-card { background: rgba(30, 33, 55, 0.7); padding: 15px; border-radius: 14px; margin-bottom: 20px; }
        .info-card h3 { font-size: 14px; margin-bottom: 12px; color: #a0aec0; display: flex; align-items: center; gap: 8px; }
        .info-item { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 13px; }
        .info-value { color: #6c8dfa; font-weight: 600; }
        .pulse { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #48bb78; margin-right: 8px; box-shadow: 0 0 0 rgba(72,187,120,0.4); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(72,187,120,0.4); } 70% { box-shadow: 0 0 0 10px rgba(72,187,120,0); } 100% { box-shadow: 0 0 0 0 rgba(72,187,120,0); } }
        .content-area { flex: 1; padding: 20px; overflow-y: auto; height: calc(100vh - 120px); }
        .data-card { background-color: rgba(40, 45, 65, 0.8); padding: 15px; border-radius: 10px; border-left: 3px solid #6c8dfa; margin-bottom: 15px; animation: fadeIn 0.5s; }
        .data-header { display: flex; justify-content: space-between; font-size: 12px; color: #a0aec0; margin-bottom: 10px; }
        .data-body { font-size: 14px; word-break: break-word; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @media (max-width: 768px) { .main-content { flex-direction: column; } .sidebar { width: 100%; border-right: none; border-bottom: 1px solid rgba(255,255,255,0.07); } .content-area { height: auto; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header"><h1><i class="fas fa-shield-halved"></i> Панель Администратора</h1></div>
        <div class="main-content">
            <div class="sidebar">
                <div class="info-card" id="stats-card"><h3><i class="fas fa-chart-simple"></i> Статистика</h3></div>
            </div>
            <div class="content-area" id="content-area"><h2><i class="fas fa-spinner fa-spin"></i> Загрузка данных...</h2></div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            Telegram.WebApp.ready();
            const statsCard = document.getElementById('stats-card');
            const contentArea = document.getElementById('content-area');

            async function loadData() {
                try {
                    const stats_res = await fetch('/api/stats');
                    const stats = await stats_res.json();
                    statsCard.innerHTML = `<h3><i class="fas fa-chart-simple"></i> Статистика</h3>
                        <div class="info-item"><span>Пользователей:</span><span class="info-value">${stats.users_count}</span></div>
                        <div class="info-item"><span>Сообщений:</span><span class="info-value">${stats.messages_count}</span></div>
                        <div class="info-item"><span>Ссылок:</span><span class="info-value">${stats.links_count}</span></div>`;

                    const messages_res = await fetch('/api/messages');
                    const messages = await messages_res.json();
                    contentArea.innerHTML = '<h2>Последние сообщения</h2>';
                    if (messages.length > 0) {
                        messages.forEach(msg => {
                            const card = document.createElement('div');
                            card.className = 'data-card';
                            card.innerHTML = \`
                                <div class="data-header">
                                    <span><b>От:</b> ${msg.from_username || 'ID: '+msg.from_user_id} <b>Кому:</b> ${msg.to_username || 'ID: '+msg.to_user_id}</span>
                                    <span>${new Date(msg.created_at).toLocaleString()}</span>
                                </div>
                                <div class="data-body">
                                    <p>${msg.message_text || `<i>(${msg.message_type})</i>`}</p>
                                </div>\`;
                            contentArea.appendChild(card);
                        });
                    } else {
                        contentArea.innerHTML += '<p>Сообщений пока нет.</p>';
                    }
                } catch (error) {
                    contentArea.innerHTML = '<h2>Ошибка загрузки данных.</h2>';
                    console.error('Fetch error:', error);
                }
            }
            loadData();
        });
    </script>
</body>
</html>
"""

# ========== КОД ВЕБ-СЕРВЕРА (FLASK) ==========
app = Flask(__name__)

def get_db_connection():
    conn = sqlite3.connect('anon_bot.db', check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

@app.route('/')
def index(): return HTML_TEMPLATE

@app.route('/api/stats')
def get_stats():
    conn = get_db_connection()
    stats = {
        'users_count': conn.execute('SELECT COUNT(*) FROM users').fetchone()[0],
        'links_count': conn.execute('SELECT COUNT(*) FROM links').fetchone()[0],
        'messages_count': conn.execute('SELECT COUNT(*) FROM messages').fetchone()[0]
    }
    conn.close()
    return jsonify(stats)

@app.route('/api/messages')
def get_messages():
    conn = get_db_connection()
    messages = conn.execute('''
        SELECT m.*, uf.username as from_username, ut.username as to_username
        FROM messages m
        LEFT JOIN users uf ON m.from_user_id = uf.user_id
        LEFT JOIN users ut ON m.to_user_id = ut.user_id
        ORDER BY m.created_at DESC LIMIT 50
    ''').fetchall()
    conn.close()
    return jsonify([dict(row) for row in messages])

def run_flask():
    # Используем Waitress, так как он проще и надежнее для таких задач, чем встроенный сервер Flask
    serve(app, host='0.0.0.0', port=8080)

# ========== КОД ТЕЛЕГРАМ-БОТА ==========
def init_db():
    conn = sqlite3.connect('anon_bot.db'); cursor = conn.cursor()
    cursor.execute('CREATE TABLE IF NOT EXISTS users (user_id INTEGER PRIMARY KEY, username TEXT, first_name TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)')
    cursor.execute('CREATE TABLE IF NOT EXISTS links (link_id TEXT PRIMARY KEY, user_id INTEGER, title TEXT, description TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (user_id) REFERENCES users (user_id))')
    cursor.execute('CREATE TABLE IF NOT EXISTS messages (message_id INTEGER PRIMARY KEY AUTOINCREMENT, link_id TEXT, from_user_id INTEGER, to_user_id INTEGER, message_text TEXT, message_type TEXT DEFAULT \'text\', file_id TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (link_id) REFERENCES links (link_id))')
    conn.commit(); conn.close()

# ... (все остальные функции вашего бота: save_user, create_anon_link, и т.д.) ...
def save_user(uid, uname, fname):
    conn = sqlite3.connect('anon_bot.db'); cursor = conn.cursor()
    cursor.execute('INSERT OR REPLACE INTO users (user_id, username, first_name) VALUES (?, ?, ?)', (uid, uname, fname))
    conn.commit(); conn.close()

def create_anon_link(uid, title, desc):
    link_id = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(10))
    conn = sqlite3.connect('anon_bot.db'); cursor = conn.cursor()
    cursor.execute('INSERT INTO links (link_id, user_id, title, description) VALUES (?, ?, ?, ?)', (link_id, uid, title, desc))
    conn.commit(); conn.close()
    return link_id

def get_link_info(link_id):
    conn = sqlite3.connect('anon_bot.db'); cursor = conn.cursor()
    cursor.execute('SELECT l.user_id, l.title, l.description, u.username FROM links l JOIN users u ON l.user_id = u.user_id WHERE l.link_id = ?', (link_id,))
    info = cursor.fetchone(); conn.close()
    return info

def save_message(link_id, from_uid, to_uid, text, mtype='text', fid=None):
    conn = sqlite3.connect('anon_bot.db'); cursor = conn.cursor()
    cursor.execute('INSERT INTO messages (link_id, from_user_id, to_user_id, message_text, message_type, file_id) VALUES (?, ?, ?, ?, ?, ?)', (link_id, from_uid, to_uid, text, mtype, fid))
    mid = cursor.lastrowid
    conn.commit(); conn.close()
    return mid

def escape_markdown(text):
    if not text: return ""
    return re.sub(f'([{re.escape(r"_*[]()~`>#+-=|{}.!")}])', r'\\\1', str(text))

# --- Клавиатуры ---
def main_keyboard():
    return InlineKeyboardMarkup([[InlineKeyboardButton("➕ Создать ссылку", callback_data="create_link")]])

def admin_keyboard():
    # WEB_APP_URL должен быть установлен перед вызовом этой функции
    return InlineKeyboardMarkup([[InlineKeyboardButton("👁️ Открыть веб-панель", web_app=WebAppInfo(url=WEB_APP_URL))]])
        
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    save_user(user.id, user.username, user.first_name)
    if context.args:
        link_id = context.args[0]
        link_info = get_link_info(link_id)
        if link_info:
            context.user_data['current_link'] = link_id
            await update.message.reply_text(f"🔗 *Анонимная ссылка*\n\n✍️ Напишите ваше сообщение или отправьте медиа\\.", parse_mode='MarkdownV2')
            return
    await update.message.reply_text("👋 *Добро пожаловать в Анонимный Бот\\!*\n\nНажмите кнопку, чтобы создать свою анонимную ссылку.", reply_markup=main_keyboard(), parse_mode='MarkdownV2')

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query; await query.answer()
    if query.data == "create_link":
        context.user_data['state'] = 'creating_link_title'
        await query.message.reply_text("📝 Введите название для вашей ссылки:")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user; text = update.message.text
    save_user(user.id, user.username, user.first_name)
    state = context.user_data.get('state')

    if state == 'creating_link_title':
        context.user_data['link_title'] = text
        context.user_data['state'] = 'creating_link_desc'
        await update.message.reply_text("📋 Теперь введите описание:")
        return

    if state == 'creating_link_desc':
        link_id = create_anon_link(user.id, context.user_data['link_title'], text)
        link_url = f"https://t.me/{context.bot.username}?start={link_id}"
        await update.message.reply_text(f"✅ *Ссылка создана\\!*\n\nВаша ссылка для получения сообщений:\n`{link_url}`", parse_mode='MarkdownV2', reply_markup=main_keyboard())
        context.user_data.clear()
        return

    if context.user_data.get('current_link'):
        link_id = context.user_data['current_link']
        link_info = get_link_info(link_id)
        if link_info:
            to_user_id = link_info[0]
            save_message(link_id, user.id, to_user_id, text)
            try:
                await context.bot.send_message(chat_id=to_user_id, text=f"📨 *Новое анонимное сообщение*\n\n{escape_markdown(text)}", parse_mode='MarkdownV2')
            except Exception as e: logger.error(f"Notify failed for {to_user_id}: {e}")
            await update.message.reply_text("✅ Отправлено анонимно!", reply_markup=main_keyboard())
            context.user_data.pop('current_link', None)
        return

    await update.message.reply_text("Используйте /start для начала работы.", reply_markup=main_keyboard())

# ... (остальные обработчики: handle_media, admin) ...
async def handle_media(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not context.user_data.get('current_link'): return
    link_id, link_info = context.user_data['current_link'], get_link_info(context.user_data['current_link'])
    if not link_info: return
    to_user_id, caption = link_info[0], update.message.caption or ""
    
    if update.message.photo: fid, mtype = update.message.photo[-1].file_id, 'photo'
    elif update.message.video: fid, mtype = update.message.video.file_id, 'video'
    elif update.message.voice: fid, mtype = update.message.voice.file_id, 'voice'
    else: return

    save_message(link_id, user.id, to_user_id, caption, mtype, fid)
    try: await context.bot.send_message(chat_id=to_user_id, text=f"📨 *Новое медиа-сообщение ({mtype})*", parse_mode='MarkdownV2')
    except Exception as e: logger.error(f"Notify media failed for {to_user_id}: {e}")
    await update.message.reply_text("✅ Медиа отправлено анонимно!", reply_markup=main_keyboard())
    context.user_data.pop('current_link', None)

async def admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id == ADMIN_ID:
        await update.message.reply_text("🛠️ *Панель администратора*", reply_markup=admin_keyboard(), parse_mode='MarkdownV2')

# ========== ТОЧКА ВХОДА ==========
async def main():
    # Создаем таблицы в БД, если их нет
    init_db()
    
    # Создаем приложение бота
    builder = Application.builder().token(BOT_TOKEN)
    application = builder.build()

    # Регистрируем обработчики
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("admin", admin))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    application.add_handler(MessageHandler(filters.PHOTO | filters.VIDEO | filters.VOICE, handle_media))
    
    # Запускаем бота
    logger.info("Бот запускается...")
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    logger.info("Бот успешно запущен.")
    
    # Ожидаем завершения
    # В этой асинхронной версии основной цикл будет работать в application.run_polling()
    # Мы просто дадим ему работать вечно.
    import asyncio
    while True:
        await asyncio.sleep(3600)

if __name__ == "__main__":
    # Запускаем Flask в отдельном потоке
    flask_thread = Thread(target=run_flask)
    flask_thread.daemon = True
    flask_thread.start()
    logger.info("Веб-сервер запущен на порту 8080.")

    # Получаем URL для WebApp после запуска Render
    # Render предоставляет URL в переменной окружения RENDER_EXTERNAL_URL
    render_url = os.environ.get('RENDER_EXTERNAL_URL')
    if render_url:
        WEB_APP_URL = render_url
        logger.info(f"URL для WebApp установлен: {WEB_APP_URL}")
    else:
        logger.warning("Переменная RENDER_EXTERNAL_URL не найдена. WebApp может не работать.")

    # Запускаем основную асинхронную функцию бота
    import asyncio
    asyncio.run(main())
